1) Crearea codului de encriptare/decriptare a imaginilor: in ambele situatii m-am folosit de PIL pentru prelucrarea imaginilor
	-Encriptarea imaginilor: Primeste ca parametrii calea catre imagine si mesajul. Prima oara se deschidea imaginea primita si se obineau dimensiunile. Apoi pentru fiecare litera se incriptau bitii in 3 biti ai imaginii conform formulei primite in cerinta si se modifica imaginea. La final, se mai adauga inca 8 biti de 0, pentru a se asigura ca stringul are caracter NULL de terminare, apoi se salva imaginea in cadrul programului si se returna calea catre imagine, ca mai apoi sa fie trimisa pentru descarcare;
	-Decriptarea imaginilor: Primeste ca argument calea catre o imagine. La fel, obtine prima oara dimensiunile pentru imagine si dupa parcuge imaginea pixel cu pixel luand bitii din 3 pixeli sa obtina o litera. Face acest lucru, pana litera obtinuta etse chiar caracterul NULL (adica 0 in ASCII) cand de opreste si returneaza sirul de caractere obtinut.

2) Inceperea crearii User Interface: am inceput initial prin crearea indexului in mod local, fara a ma folosi de flask deoarece am considerat ca va fi usor sa fac prima oara totul local si dupa sa il duc in flask. Asa ca index.html si style.css au fost facute pe moment doar gandindu-ma ca ar fi local. Ce mi se pare mai interesant este ca exemplul din home cu imaginile se va adapta pentru imaginile trimise de utilizator, totusi la rularea initiala o sa aiba un exemplu mai general (cel de inceput). In momentul cand am inceput sa implementez 'encode.html' am realizat ca nu mai pot lucra local si trebuie sa incep in flask pentru a putea folosi scripturile create anterior.

3) Flask: aici am intampinat primele probleme majore cand am realizat ca trebuie sa fiu foarte atent cand ma refer la ceva din flask sau la un fisier din folderul meu, de multe ori realizand greu ca le-am interschimbat pozitiile celor 2 si de aia nu imi mergea ori sa deschid pagina respectiva, ori sa apelez un script. O alta problema s-a intampinat sa fie faptul ca am dorit sa se poate visualiza imaginea care este trimisa sa fie incriptata/decriptata. Pentru asta m-am folosit de un scurt cod in javascript. O alta modificare facuta in faza aceasta a terminarii temei a fost sa pun partea de sidebar intr-un template separat si sa o adaug in celelalte 3 pagini folosindu-ma de Jinja. Pe langa cea de index, despre care am vorbit, am mai creat inca 2 pagini html:
	-encode.html: Aici se afla 2 posibilitati: prima este sa incodezi un mesaj intr-o imagine dorita (de tip png). In momentul cand se apasa si butonul 'Encode' imaginea va fi si descarcata. A doua optine este ca daca mai vrei sa fie inca o data descarcata ultima creata, se poate face acest lucru prin apasarea butonului "Get Encoded Image";
	-decode.html: Aici iarasi sunt 2 posibilitati: sa trimiti o imagine pentru decodarea mesajului din aceasta, care va aparea pe ecran, sau sa obtii ultimul mesaj decodat. A doua optiune nu va fi valabila pana cand nu este decodata cel putin o imagine. Dupa asta va aparea butonul "Download Last Decoded Message" care va descarca mesajul intr-un fisier text(nu am inteles exact cerinta la partea cu binar, am considerat ca si asa este o metoda buna pentru lucrurile de tip text).
	
4) Docker: pentru docker, problema mare a fost pana am realizat ce trebuia sa adaug in app.py (linia 227) pentru a se putea deschide site-ul pe 'http://localhost:8080'. Alta problema intampinata a fost ca daca in'requirements.txt' adaugam si versiunea, nu reusea sa imi contruiasca imaginea, asa ca m-am hotarat sa il las fara versiune specificata si a mers. In rest partea de docker a mers usor.

5) FEEDBACK: din ce am auzit si de la alti elevi cum sunt materiile de la restul optionalelor, acesta mi s-a parut cea mai interesant optional dintre toate. Pacatul mare despre materie este ca sunt foarte multe concepte noi si chiar foarte fascinante, dar timpul alocat mi s-a parut prea putin pentru a invata cum trebuie toate acestea. Tema insasi m-a ajutat sa le stapanesc mai bine si chiar as spera sa mai fie proiecte in anii mai mari in care sa ne folosim iar de flask si docker.
